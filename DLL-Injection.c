#include <Windows.h>
#include <iostream>
#include <string>
#include <TlHelp32.h>
void exploitRoblox() {
   // now, you can add ur logic for script execution
   // for debug, it will just print.
    std::cout << "injection success." << std::endl;
}
void injectRoblox() {
    DWORD processId = 0;
    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (Process32First(snapshot, &processEntry)) {
        do {
            if (strcmp(processEntry.szExeFile, "RobloxPlayerBeta.exe") == 0) {
                processId = processEntry.th32ProcessID;
                break;
            }
        } while (Process32Next(snapshot, &processEntry));
    }
    CloseHandle(snapshot);
    if (processId == 0) {
        std::cout << Injection failed." << std::endl;
        return;
    }
    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (processHandle == NULL) {
        std::cout << "Injection failed." << std::endl;
        return;
    }
    const char* dllPath = "Executor.dll"; // make sure to replace
    LPVOID dllPathAddr = VirtualAllocEx(processHandle, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (dllPathAddr == NULL) {
        std::cout << "Injection failed." << std::endl;
        CloseHandle(processHandle);
        return;
    }
    if (!WriteProcessMemory(processHandle, dllPathAddr, dllPath, strlen(dllPath) + 1, NULL)) {
        std::cout << "Injection failed." << std::endl;
        VirtualFreeEx(processHandle, dllPathAddr, 0, MEM_RELEASE);
        CloseHandle(processHandle);
        return;
    }
    LPVOID loadLibraryAddr = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    if (loadLibraryAddr == NULL) {
        std::cout << "Injection failed." << std::endl;
        VirtualFreeEx(processHandle, dllPathAddr, 0, MEM_RELEASE);
        CloseHandle(processHandle);
        return;
    }
    HANDLE remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, dllPathAddr, 0, NULL);
    if (remoteThread == NULL) {
        std::cout << "Injection failed." << std::endl;
        VirtualFreeEx(processHandle, dllPathAddr, 0, MEM_RELEASE);
        CloseHandle(processHandle);
        return;
    }
    WaitForSingleObject(remoteThread, INFINITE);
    CloseHandle(remoteThread);
    VirtualFreeEx(processHandle, dllPathAddr, 0, MEM_RELEASE);
    CloseHandle(processHandle);

    std::cout << "Injection successful." << std::endl;
}
bool checkKey(std::string key) {
    return !key.empty();
}
int main() {
    std::string userKey;
    std::cout << "Enter your access key: ";
    std::cin >> userKey;
    if (!checkKey(userKey)) {
        std::cout << "Invalid key! Access denied." << std::endl;
        return 1;
    }
    exploitRoblox();
    injectRoblox();
    return 0;
}
